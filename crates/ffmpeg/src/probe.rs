use crate::{
	dict::FFmpegDict,
	error::Error,
	format_ctx::FFmpegFormatContext,
	model::MediaInfo,
	utils::{from_path, CSTRING_ERROR_MSG},
};

use ffmpeg_sys_next::{av_log_set_level, AV_LOG_FATAL};

use std::{ffi::CString, path::Path};

pub fn probe(filename: impl AsRef<Path>) -> Result<MediaInfo, Error> {
	let filename = filename.as_ref();

	// Reduce the amount of logs generated by FFmpeg
	unsafe { av_log_set_level(AV_LOG_FATAL) };

	// Dictionary to store format options
	let mut format_opts = FFmpegDict::new(None);
	// Some MPEGTS specific option (copied from ffprobe)
	let scan_all_pmts = CString::new("scan_all_pmts").expect(CSTRING_ERROR_MSG);
	format_opts.set(
		scan_all_pmts.to_owned(),
		CString::new("1").expect(CSTRING_ERROR_MSG),
	)?;

	// Open an input stream, read the header and allocate the format context
	let fmt_ctx = FFmpegFormatContext::open_file(from_path(filename)?, &mut format_opts)?;

	// Reset MPEGTS specific option
	format_opts.remove(scan_all_pmts)?;

	// Read packets of media file to get stream information.
	fmt_ctx.find_stream_info()?;

	let media_info = MediaInfo {
		formats: fmt_ctx.formats(),
		duration: fmt_ctx.duration(),
		start_time: fmt_ctx.start_time(),
		bitrate: fmt_ctx.bit_rate(),
		chapters: fmt_ctx.chapters(),
		programs: fmt_ctx.programs(),
		metadata: fmt_ctx.metadata(),
	};

	Ok(media_info)
}
